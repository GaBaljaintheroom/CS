# 3장 소스 코드와 명령어

### 고급언어와 저급언어

**고급언어**

- 사람을 위한 언어

**저급언어**

- 컴퓨터가 직접 이해학 실행할 수 있는 언어
- 기계어
    - 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어
    - 0과 1로 표현된 명령어(기계어)를 읽기 편한 행태로 번역한 언어

### 컴파일 언어와 인터프리터 언어

**컴파일 언어**

- 컴파일 방식으로 작동하는 프로그래밍 언어
- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급언어
- 컴파일
    - 컴파일 언어로 작성된 소스 코드는 컴파일러에 의해 저급 언어로 변환되는 과정
    - 목적 코드 : 컴파일 결과인 저급 언어

**인터프리트 언어**

- 인터프리트 방식으로 작동하는 프로그래밍 언어
- 소스 코드를 한 줄 씩 저급 언어로 변환하여 실행해주는 도구

### 목적 파일과 실행 파일

**목적 파일**

- 목적 코드로 이루어진 파일

**실행 파일**

- 실행 코드로 이루어진 파일

목적 코드가 실행 파일이 되기 위해서는 **링킹 작업**을 거쳐야함

### **명령어 : 연산코드 + 오퍼랜드**

- 연산코드(연산자) : 명령어가 수행할 연산
- 연산코드 필드 : 연산 코드가 담긴 영역
- 오퍼랜드(피연산자) : 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
    - 숫자나 문자와 같이 연산에 사용할 데이터, 메모리나 레지스터 주소
- 오퍼랜드 필드(주소 필드) : 오퍼랜드가 담기는 영역
- 0-주소 명령어 : 오퍼랜드가 하나도 없는 명령어
- 1-주소 명령어 : 오퍼랜드가 하나인 명령어
- 2-주소 명령어 : 오퍼랜드가 두 개인 명령어

### 주소 지정 방식

- **오퍼랜드 필드에 주소를 명시하는 이유 :** 표현할 수 있는 데이터의 크기를 키우기 위해
- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식
- **유효 주소 :** 연산의 대상이 되는 데이터가 저장된 위치

**즉시 주소 지정 방식**

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방법
- 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠름
- 표현할 수 있는 데이터의 크기가 작아짐

**직접 주소 지정 방식**

- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생김

**간접 주소 지정 방식**

- 유효 주소의 주소를 오퍼랜드 필드에 명시
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐
    - 명령어가 직접 지정하는 주소 공간은 작지만, 그 주소가 가리키는 실제 메모리 공간은 훨씬 더 클 수 있기 때문
- 두 번의 메모리 접근이 필요하기 때문에 일반적으로 느린 방식

**레지스터 주소 지정 방식**

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
- CPU 안에 레지스터가 있어 빠름
- 표현할 수 있는 레지스터 크기에 제한이 생김

**레지스터 간접 주소 지정 방식**

- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
- 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수를 한 번으로 줄어듬